# physics_models
# This file contains global variables and parameters used across the OSPM codebase.

import numpy as np
import math
from scipy.constants import G, c, pi

GG = G
C = c
Msun = 1.98847e30
kpc_to_m = 3.085677581e19
arcsec_to_rad = np.deg2rad(1/3600)

###################################################################################
# Fundamentals
###################################################################################
def summ(w, xlib, v1lib, Nbin, Norbit, Nvelb, Nvel):
    summed = np.zeros(Nbin + Nvelb * Nvel, dtype=np.float32)

    for ibin in range(Nbin):
        total = 0.0
        for iorb in range(Norbit):
            total += float(w[iorb] * xlib[ibin, iorb])
        summed[ibin] = total

    for irc in range(Nvelb):
        for ivel in range(Nvel):
            i = Nbin + irc * Nvel + ivel
            total = 0.0
            for iorb in range(Norbit):
                total += float(w[iorb] * v1lib[ivel, irc, iorb])
            summed[i] = total

    return summed

def ekin(r, v, Etot, xLz, potential_func): # Kinetic energy
    VV = potential_func(r, v)
    return Etot - VV - (xLz * xLz) / (r * r * (1.0 - v * v) * 2.0)

def force():
    pass

def forcefix():
    pass


def energy(r, th, vr, vth, xLz, potential_func):
    v = np.sin(th)
    vco = np.cos(th)
    vph = xLz / (r * vco)
    VV = potential_func(r, v)
    return 0.5 * (vr**2 + vth**2 + vph**2) + VV


def entropy():
    """Entropy = profit function: entropy term minus χ² terms."""
    pass

def velocity():
    pass

def phase_volume():
    """Calculates orbit phase-space volume."""
    pass

def Lagrangian():
    pass

def potential(r, v, nlegup, npot, rlgpotmin, rlgpotmax, RneeIRhalo, tabv, hole, totlight, gdennorm, Pl):
    rir = (np.log10(r) - rlgpotmin) * (npot - 1) / (rlgpotmax - rlgpotmin) + 1.0
    irlo = int(rir)
    irup = int(rir + 1.0)

    rlo = RneeIRhalo[irlo]
    rup = RneeIRhalo[irup]
    rdiff = r - rlo

    VVlo = 0.0
    VVup = 0.0

    # Linearly interpolate over Legendre orders 0, 2, ..., nlegup
    for n in range(0, nlegup + 1, 2):
        nleg = n // 2
        term = 0.0 if irlo == 0 else Pl(n, v) * tabv[nleg, irlo]
        VVlo += term
        VVup += Pl(n, v) * tabv[nleg, irup]

    VV = VVlo + (VVup - VVlo) / (rup - rlo) * rdiff
    VV = -2.0 * np.pi * VV - hole / (totlight * gdennorm * r)
    return VV

def seecor():
    pass

def radius():
    pass

def density():
    pass

###################################################################################
# Halo Model
###################################################################################

def halodens():
    pass



###################################################################################
# Orbit Model
###################################################################################

def orbits():
    pass

def area():
    pass

def model():
    """Calculates orbit weights matching 2-D profile while maximizing entropy."""
    pass

def projmass():
    """Projects orbit mass distributions."""
    pass


###################################################################################
# Analysis
###################################################################################

def weights():
    pass

def fitting():
    pass


###################################################################################
# Derivative Function (used in RK4 integration)
###################################################################################

def dervis(pos0, xLz, force_func):
    """Compute RK4 derivatives from Legendre polynomial-expanded potential."""
    r, th, vr, vth = pos0
    v = np.sin(th)
    vph = xLz / (r * np.cos(th))

    frL, fvL = force_func(r, v)

    dposdt = np.zeros(4)
    dposdt[0] = vr
    dposdt[1] = vth / r
    dposdt[2] = (vth**2 + vph**2) / r + frL
    dposdt[3] = -np.tan(th) * vph**2 / r - vth * vr / r + fvL
    return dposdt


###################################################################################
# function to compute the LOSVD from orbit weights
###################################################################################
def vor2vphase(sos_sum, dEdLz, I3=None, tiny=1e-10):
    sos_sum = np.array(sos_sum, dtype=float)
    dEdLz = np.array(dEdLz, dtype=float)

    # Handle bad or zero entries
    valid_mask = (sos_sum > 0) & (dEdLz > 0)
    phasevol = np.zeros_like(sos_sum)

    # Compute phase volume: V_i = 1 / (sos_sum * dEdLz)
    with np.errstate(divide="ignore", invalid="ignore"):
        phasevol[valid_mask] = np.abs(1.0 / (sos_sum[valid_mask] * dEdLz[valid_mask]))

    # Replace invalid entries with small fallback value
    phasevol[~valid_mask] = tiny

    # Normalize to match Fortran normalization block
    inv_sum = np.sum(1.0 / np.maximum(phasevol, tiny))
    phasevol *= inv_sum

    return phasevol, valid_mask

def vlook(v1lib, w, Norbit, Nvel, Nvelb):
    """Equivalent to vlook.f — constructs the LOSVD grid from orbit weights."""
    y1 = np.zeros((Nvel, Nvelb))
    for iorb in range(Norbit):
        y1 += w[iorb] * v1lib[:, :, iorb]
    return y1

# Full diagnostic + projection analysis (vlookjm.f)
def vlookjm(v1lib, w, sumad, sadfer, velm, Nvel, Nvelb, Norbit):
    """Equivalent to vlookjm.f — computes projected profiles, H3/H4, and χ²."""

    # === Nested helpers =======================================================
    def get_fwhm(x, y):
        half_max = np.max(y) / 2.0
        indices = np.where(y >= half_max)[0]
        if len(indices) < 2:
            return np.nan
        return x[indices[-1]] - x[indices[0]]

    def gauss_hermite(v, A, v0, sigma, h3, h4):
        """Simple normalized Gauss–Hermite expansion (up to h4)."""
        u = (v - v0) / sigma
        herm3 = (2 * u**3 - 3 * u) / np.sqrt(6)
        herm4 = (4 * u**4 - 12 * u**2 + 3) / np.sqrt(24)
        base = np.exp(-0.5 * u**2)
        return A * base * (1 + h3 * herm3 + h4 * herm4)

    def fit_gauss_hermite(v, f):
        """Fit LOSVD to a Gauss–Hermite expansion."""
        A0 = np.trapz(f, v)
        v0_guess = np.sum(v * f) / np.sum(f)
        sigma_guess = np.sqrt(np.sum((v - v0_guess) ** 2 * f) / np.sum(f))
        popt, _ = curve_fit(
            gauss_hermite, v, f, p0=[A0, v0_guess, sigma_guess, 0.0, 0.0],
            maxfev=10000
        )
        return popt  # (A, v0, sigma, h3, h4)

    def chi_square(model, data, err):
        valid = err > 0
        return np.sum(((model[valid] - data[valid]) / err[valid]) ** 2)

    # === Main computations ====================================================
    y1 = vlook(v1lib, w, Norbit, Nvel, Nvelb)
    sigm, sigd, velmp, veldp, h3m, h4m, h3d, h4d = (
        np.zeros(Nvelb) for _ in range(8)
    )
    chi_arr = np.zeros(Nvelb)

    for ivbin in range(Nvelb):
        y1p = y1[:, ivbin]
        datap = sumad[:, ivbin]
        errv = sadfer[:, ivbin]

        # Model fit
        A, v0, sigma, h3, h4 = fit_gauss_hermite(velm, y1p)
        velmp[ivbin], sigm[ivbin], h3m[ivbin], h4m[ivbin] = v0, sigma, h3, h4

        # Data fit
        A, v0, sigma, h3, h4 = fit_gauss_hermite(velm, datap)
        veldp[ivbin], sigd[ivbin], h3d[ivbin], h4d[ivbin] = v0, sigma, h3, h4

        chi_arr[ivbin] = chi_square(y1p, datap, errv)

    # === Plot example (projected σ) ===========================================
    plt.figure(figsize=(7, 5))
    plt.plot(sigd, label="Observed σ")
    plt.plot(sigm, label="Model σ")
    plt.xlabel("Velocity bin index")
    plt.ylabel("σ (km/s)")
    plt.legend()
    plt.title("Projected Velocity Dispersion")
    plt.show()

    return {
        "velmp": velmp, "sigd": sigd, "sigm": sigm,
        "veldp": veldp, "h3m": h3m, "h4m": h4m,
        "h3d": h3d, "h4d": h4d, "chi2": chi_arr,
    }
